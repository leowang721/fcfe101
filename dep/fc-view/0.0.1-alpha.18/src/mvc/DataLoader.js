/**
 * @file fc-view DataLoader 数据加载器
 * 当前整体模式基于ecomfe/er/4.0/feature/mvc的DataLoader实现
 *
 * @author Gray Zhang(otakustay@gmail.com)
 * @author Leo Wang(wangkemiao@baidu.com)
 */
define(
    function (require) {
        /**
         * 以下结构可以作为数据加载的配置：
         *
         * - 一个函数，用作某个对象的某个属性时，函数会被直接执行，其返回值（或`Promise`的`resolve`值）会被作为获取的数据
         * - 一个对象，其中的键名为对象名，值为另一个数据加载的配置，此时表示这些项需要 **并行** 加载
         * - 一个数组，每一项为一个数据加载的配置，此时表示这些项需要 **串行** 加载
         * - 一个带有`retrieve`的对象，被作为{@link meta.DataLoaderItem}使用，调用`retrieve`方法加载数据
         *
         * @typedef {Function | meta.DataLoaderItem | Object.<string, DataConfig> | DataConfig[]} DataConfig
         */

        var Promise = require('promise');
        var u = require('underscore');

        /**
         * 数据加载对象，可根据配置进行数据加载
         *
         * @class DataLoader
         */
        var exports = {};

        /**
         * @constructs DataLoader
         */
        exports.constructor = function () {
            /**
             * 保存数据加载的配置
             *
             * @member DataLoader#.config
             *
             * @type {Array}
             * @private
             */
            this.config = [];

            /**
             * 保存正在运行中的数据加载过程
             *
             * @member DataLoader#.pendingWorkers
             *
             * @type {Promise[]}
             * @private
             */
            this.pendingWorkers = [];
        };

        /**
         * 获取数据加载的配置
         *
         * @method DataLoader#.getConfig
         *
         * @return {Array}
         * @protected
         */
        exports.getConfig = function () {
            return this.config;
        };

        /**
         * 添加一个数据加载的配置
         *
         * @method DataLoader#.put
         *
         * @param {Object.<string, DataConfig> | DataConfig[]} item 需要添加的配置项，包含一个或多个指定名称的数据加载配置
         * @param {number} index 添加的位置，同一位置的配置项会被并行加载
         * @public
         */
        exports.put = function (item, index) {
            if (!this.config) {
                throw new Error('This DataLoader is disposed');
            }
            if (!item) {
                throw new Error('Argument item is not provided');
            }

            // 如果直接就给了一个函数，就当是数组来简化处理，避免下面的`extend`要对函数特殊处理
            if (typeof item === 'function') {
                item = [item];
            }

            if (!u.isArray(item) && !u.isObject(item)) {
                throw new Error('Argument item must be of type object or array');
            }

            var config = this.getConfig();

            if (index === undefined) {
                index = config.length;
            }

            // 每个位置里的各配置是并行的，在这里保证取出来的一定会是对象
            var originalItem = config[index];
            if (!originalItem) {
                originalItem = config[index] = {};
            }
            // 如果给的是一个数组，则随便找个键名放这个数组，因为这个键名已经没有意义了
            if (u.isArray(item)) {
                var sequentialConfig = item;
                item = {};
                item[u.uniqueId('erAutoGeneratedDataUnit')] = sequentialConfig;
            }
            u.extend(originalItem, item);
        };

        /**
         * 加载数据
         *
         * @method DataLoader#.load
         *
         * @return {Promise} 会返回在配置中包含的全部数据加载项的结果{@link meta.DataLoadResult}对象，不保证顺序
         */
        exports.load = function () {
            if (!this.config) {
                throw new Error('This DataLoader is disposed');
            }

            var config = this.getConfig();
            // 为了控制流程简便，同时考虑到无论成功与否最后的对象结构是相似的，所以加载单个数据统一只会成功不会失败，
            // 通过`success`属性来表示真实的加载情况，最后在`reportLoadResult`中统一判断来分流`Promise`的结果
            return this.loadByConfig(config).then(u.bind(this.reportLoadResult, this));
        };

        /**
         * 提供数据加载最终结果
         *
         * 这个方法会根据数据加载的结果来选择返回（正常）或抛出异常（失败），但返回值和抛出的异常内容是一样的
         *
         * @private
         * @method DataLoader#.reportLoadResult
         * @param {DataLoadResult[]} results 结果集存储
         * @return {DataLoadResult[]} 如果所有数据加载成功，返回所有加载结果
         * @throws {DataLoadResult[]} 如果有任何一个或以上的数据加载未成功，则抛出所有加载结果
         */
        exports.reportLoadResult = function (results) {
            var isSuccess = u.all(results, 'success');
            if (isSuccess) {
                return results;
            }

            throw results;
        };

        /**
         * 处理数据加载错误
         * 正常返回表示错误已经处理，返回值作为数据加到`store`中
         * 抛出异常则认为错误未处理，将异常作为错误继续传递
         *
         * @protected
         * @method DataLoader#.handleError
         *
         * @param {meta.DataLoadResult} error 错误信息，其中{@link meta.DataLoadResult#.success|success属性}一定为`false`
         * @param {meta.DataLoaderItem} item 加载的配置项
         */
        exports.handleError = function (error, item) {
            throw error.error;
        };

        /**
         * 构建一个表达加载出错的{@link meta.DataLoadResult}对象
         *
         * @method DataLoader#.buildError
         *
         * @param {meta.DataLoaderItem} item 加载的配置项
         * @param {Error} ex 错误对象
         * @return {meta.DataLoadResult} 一个表示加载出错的对象
         *
         * @private
         */
        exports.buildError = function (item, ex) {
            return {
                success: false,
                name: item.name,
                options: item,
                error: ex
            };
        };

        /**
         * 尝试处理错误，如果处理成功则回到成功状态，否则进入异常状态
         *
         * @method DataLoader#.tryHandleError
         *
         * @param {meta.DataLoaderItem} item 加载的配置项
         * @param {Error} ex 错误对象
         * @return {Promise} 当成功处理异常时进入`resolved`状态，否则进入`rejected`状态
         *
         * @private
         */
        exports.tryHandleError = function (item, ex) {
            var error = this.buildError(item, ex);
            // `Promise`的`exeecutor`抛出异常后会自动进入`rejected`状态
            try {
                var handleResult = this.handleError(error, item);
                return Promise.resolve(handleResult).then(
                    u.bind(this.addValueToStore, this, item), // 异常处理掉了，则返回值作为最终结果存下来
                    u.bind(this.buildError, this, item) // 还是出错了，则直接把错误抛出去
                );
            }
            catch (furtherError) {
                var errorResult = this.buildError(item, furtherError);
                return Promise.resolve(errorResult);
            }
            // var handling = new Promise(u.bind(this.handleError, this, error, item));
            // return handling.then(u.bind(this.addValueToStore, this, item), u.bind(this.buildError, this, item));
        };

        /**
         * 将加载的数据放入存储区域
         *
         * @param {meta.DataLoaderItem} item 加载配置项
         * @param {*} value 加载的结果
         * @return {meta.DataLoadResult} 一个表示成功的对象
         */
        exports.addValueToStore = function (item, value) {
            if (item.dump) {
                this.getStore().fill(value);
            }
            else {
                this.getStore().set(item.name, value);
            }

            return {
                success: true,
                name: item.name,
                options: item,
                value: value
            };
        };

        /**
         * 根据一个配置加载数据，配置可能为单个配置项、函数、对象或数组，单个配置项或函数直接加载，剩余按照对象并行、数组串行的方式加载
         *
         * 你不知道手里的对象是什么类型时，就调用这个方法
         *
         * @method DataLoader#.loadByConfig
         *
         * @param {Array | Object | meta.DataLoaderItem | Function} config 配置项
         * @return {Promise} 会返回在`config`中包含的全部数据加载项的结果{@link meta.DataLoadResult}对象
         * @protected
         */
        exports.loadByConfig = function (config) {
            function wrapSingleResultToArray(result) {
                return [result];
            }

            // 是函数的话，函数即获取数据的函数，包装为数据获取配置项
            if (typeof config === 'function') {
                var options = {retrieve: config, dump: true};
                return this.loadSingleItem(options).then(wrapSingleResultToArray);
            }

            // 是数组的话，数组中的各项串行加载
            if (u.isArray(config)) {
                return this.loadAsSequence(config);
            }

            // 当一个对象中有`retrieve`属性就认为是一个数据获取配置项
            if (typeof config.retrieve === 'function') {
                return this.loadSingleItem(config).then(wrapSingleResultToArray);
            }

            // 是一个并行加载的配置对象
            return this.loadAsParallel(config);
        };

        /**
         * 加载单个配置项
         *
         * 这方法仅接受格式正确的{@link meta.DataLoaderItem}对象，如果没有{@link meta.DataLoaderItem#.retrieve|retrieve方法}会出错，
         * 在不知道对象格式的情况下需要使用{@link DataLoader#.loadByConfig|loadByConfig方法}
         *
         * @method meta.DataLoaderItem#.loadSingleItem
         *
         * @param {meta.DataLoaderItem} options 配置项
         * @return {Promise} 会返回`options`指定的加载项的{@link meta.DataLoadResult}对象
         * @protected
         */
        exports.loadSingleItem = function (options) {
            // 流程：
            //
            // 1. 调用`retrieve`加载数据，提供`store`和`options`作为参数
            // 2. 如果加载成功（返回`Promise`并进入`resolved`状态，或直接返回值），则：
            //     1. 将对象放到`store`中，根据`options.dump`来判断使用`set`或`fill`
            //     2. 返回一个`success`为`true`的对象说明状态
            // 3. 如果加载失败（返回`Promise`进入`rejected`状态，或抛出异常），则：
            //     1. 将异常包装为一个`success`为`false`的对象说明状态
            //     2. 调用`handleError`，提供上一步创建的`error`对象
            //     3. 如果成功处理了异常（方法正常返回，或返回`Promise`并进入`resolved`状态），则将返回的值作为最终数据，回到`2.1`步
            //     4. 如果没能处理异常（方法抛出异常，或返回`Promise`进入`rejected`状态），则：
            //         1. 再一次包装异常成`success`为`false`的对象
            //         2. 使返回的`Promise`进入`rejected`状态，以上一步得到的`error`对象为参数
            try {
                var value = options.retrieve(this.getStore(), options);
                // 此处不用`cast`，因为有需要对`abort`的处理，如果被`cast`进行了一层包装，会丢失掉`abort`方法
                var working = Promise.isPromise(value) ? value : Promise.resolve(value);
                // 加到队列中以便管理中止
                this.addPendingWorker(working);
                return working.then(
                    u.bind(this.addValueToStore, this, options),
                    u.bind(this.tryHandleError, this, options)
                );
            }
            catch (ex) {
                return this.tryHandleError(options, ex);
            }
        };

        /**
         * 并行加载一个对象中的所有配置项
         *
         * @method DataLoader#.loadAsParallel
         *
         * @param {Object} units 一个对象，其中每一项都会并行加载
         * @return {Promise} 会返回在`units`中包含的全部数据加载项的结果{@link meta.DataLoadResult}对象
         * @protected
         */
        exports.loadAsParallel = function (units) {
            function loadUnit(unit, name) {
                // 如果直接表达获取数据的内容，需要加上对应的属性名。其它情况下（值为嵌套的数组或对象），属性名将没有意义
                if (typeof unit === 'function') {
                    unit = {retrieve: unit, name: name};
                }
                else if (typeof unit.retrieve === 'function') {
                    unit = u.extend({name: name}, unit);
                }

                return this.loadByConfig(unit);
            }

            var workers = u.map(units, loadUnit, this);
            return Promise.all(workers).then(u.flatten);
        };

        /**
         * 串行加载一个对象中的所有配置项
         *
         * @method DataLoader#.loadAsSequence
         *
         * @param {Array} units 一个数组，其中每一项都会串行加载
         * @return {Promise} 会返回在`units`中包含的全部数据加载项的结果{@link meta.DataLoadResult}对象
         * @protected
         */
        exports.loadAsSequence = function (units) {
            var results = [];
            // 第一个Promise是直接成功的，以便开始第一块的加载
            var loading = Promise.resolve();
            u.each(
                units,
                function (unit) {
                    loading = loading.then(u.bind(this.loadByConfig, this, unit)).then(u.bind(results.push, results));
                },
                this
            );
            return loading.then(u.bind(u.flatten, u, results));
        };

        /**
         * 移除一个已完成的工作对象
         *
         * @method DataLoader#.removePendingWorker
         *
         * @param {Promise} worker 工作对象
         * @protected
         */
        exports.removePendingWorker = function (worker) {
            var index = u.indexOf(this.pendingWorkers, worker);
            if (index >= 0) {
                this.pendingWorkers.splice(index, 1);
            }
        };

        /**
         * 添加一个未完成的工作对象
         *
         * 将一个`Promise`对象添加到当前对象上
         *
         * - 当此`Promise`对象进入`resolved或`rejected`状态后，会自动移除
         * - 未移除的这些`Promise`对象，会在当前对象销毁果，一并进行销毁
         *
         * 在销毁一个`Promise`对象如果额外提供`abort()`方法，则调用此方法进行销毁，其它情况下直接丢弃
         *
         * @method DataLoader#.addPendingWorker
         *
         * @param {Promise} worker 工作对象
         * @protected
         */
        exports.addPendingWorker = function (worker) {
            this.pendingWorkers.push(worker);
            worker.ensure(u.bind(this.removePendingWorker, this, worker));
        };

        /**
         * 清空工作对象，对每个对象如果可以中止（有`abort`方法）则中止之
         *
         * @method DataLoader#.destroyPendingWorker
         *
         * @param {Promise} worker 需要销毁的工作对象
         * @protected
         */
        exports.destroyPendingWorker = function (worker) {
            if (typeof worker.abort === 'function') {
                try {
                    worker.abort();
                }
                catch (ex) {
                }
            }
            this.removePendingWorker(worker);
        };

        /**
         * 销毁对象
         *
         * @method DataLoader#.dispose
         */
        exports.dispose = function () {
            while (this.pendingWorkers && this.pendingWorkers.length) {
                this.destroyPendingWorker(this.pendingWorkers[0]);
            }

            this.pendingWorkers = null;
            this.store = null;
            this.config = null;
        };

        var defineAccessor = require('eoo/defineAccessor');

        /**
         * 获取数据的存放处
         *
         * @method DataLoader#.getStore
         *
         * @return {?Object} 一个有`set`和`fill`方法的对象
         * @protected
         */

        /**
         * 设置数据的存放处
         *
         * @method DataLoader#.getStore
         *
         * @param {?Object} store 数据的存放处，一个有`set`和`fill`方法的对象
         * @protected
         */
        defineAccessor(exports, 'store');

        var DataLoader = require('eoo').create(exports);
        return DataLoader;
    }
);
